{"version":3,"file":"static/js/482.1d93813f.chunk.js","mappings":"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","sources":["types/Task.ts","workers/TaskWorker.ts"],"sourcesContent":["/**\r\n * Task Priority Levels\r\n */\r\nexport enum TaskPriority {\r\n  CRITICAL = 0, // Urgent tasks that must be executed immediately\r\n  HIGH = 1, // Important tasks with high priority\r\n  MEDIUM = 2, // Normal priority tasks\r\n  LOW = 3, // Tasks that can wait if system is under load\r\n  BACKGROUND = 4, // Tasks that should only run when system is idle\r\n}\r\n\r\n/**\r\n * Task Status Values\r\n */\r\nexport enum TaskStatus {\r\n  PENDING = \"pending\", // Task is waiting to be processed\r\n  RUNNING = \"running\", // Task is currently being processed\r\n  COMPLETED = \"completed\", // Task has been successfully completed\r\n  FAILED = \"failed\", // Task has failed\r\n  CANCELLED = \"cancelled\", // Task was cancelled before completion\r\n  RETRY = \"retry\", // Task is scheduled for retry after failure\r\n}\r\n\r\n/**\r\n * Task Type - defines different types of tasks that can be processed\r\n */\r\nexport enum TaskType {\r\n  MODEL_REQUEST = \"model_request\", // Request to an AI model\r\n  EMBEDDINGS = \"embeddings\", // Generate embeddings for text\r\n  FILE_OPERATION = \"file_operation\", // File system operations\r\n  DATA_PROCESSING = \"data_processing\", // Process data\r\n  EXTERNAL_API = \"external_api\", // Call to an external API\r\n  CUSTOM = \"custom\", // Custom task type\r\n}\r\n\r\n/**\r\n * Base Task Interface\r\n *\r\n * Defines the common structure for all tasks that can be processed\r\n * by the worker system.\r\n */\r\nexport interface Task {\r\n  id: string; // Unique identifier for the task\r\n  type: TaskType; // Type of task\r\n  priority: TaskPriority; // Priority level\r\n  status: TaskStatus; // Current status\r\n  data: any; // Task data payload\r\n  createdAt: Date; // When the task was created\r\n  startedAt?: Date; // When the task started processing\r\n  completedAt?: Date; // When the task was completed\r\n  error?: Error | string; // Error information if task failed\r\n  attempts: number; // Number of attempts made\r\n  maxAttempts: number; // Maximum number of retry attempts\r\n  dependencies?: string[]; // IDs of tasks that must complete before this one\r\n  tags?: string[]; // Optional tags for categorization\r\n  workerId?: string; // ID of worker processing this task\r\n  progress?: number; // Progress percentage (0-100)\r\n  result?: any; // Task result data\r\n  processingTime?: number; // Time taken to process the task in milliseconds\r\n  dueDate?: Date; // When the task is due to be completed\r\n}\r\n\r\n/**\r\n * Task Creation Options\r\n *\r\n * Options for creating a new task.\r\n */\r\nexport interface TaskOptions {\r\n  type: TaskType;\r\n  priority?: TaskPriority;\r\n  data: any;\r\n  maxAttempts?: number;\r\n  dependencies?: string[];\r\n  tags?: string[];\r\n}\r\n\r\n/**\r\n * Worker Message Types\r\n */\r\nexport enum WorkerMessageType {\r\n  TASK_ASSIGNED = \"task_assigned\",\r\n  TASK_COMPLETED = \"task_completed\",\r\n  TASK_FAILED = \"task_failed\",\r\n  TASK_PROGRESS = \"task_progress\",\r\n  WORKER_READY = \"worker_ready\",\r\n  WORKER_BUSY = \"worker_busy\",\r\n  WORKER_ERROR = \"worker_error\",\r\n  WORKER_TERMINATED = \"worker_terminated\",\r\n}\r\n\r\n/**\r\n * Worker Message Interface\r\n *\r\n * Used for communication between the manager and worker threads.\r\n */\r\nexport interface WorkerMessage {\r\n  type: WorkerMessageType;\r\n  taskId?: string;\r\n  workerId?: string;\r\n  data?: any;\r\n  progress?: number;\r\n  error?: string;\r\n  timestamp: Date;\r\n}\r\n\r\n/**\r\n * Task Result Interface\r\n *\r\n * Standardized format for task results.\r\n */\r\nexport interface TaskResult {\r\n  taskId: string;\r\n  success: boolean;\r\n  data?: any;\r\n  error?: string;\r\n  processingTime?: number; // in milliseconds\r\n}\r\n\r\n/**\r\n * Model Request Task Data\r\n */\r\nexport interface ModelRequestTaskData {\r\n  modelId: string;\r\n  prompt: string;\r\n  temperature?: number;\r\n  maxTokens?: number;\r\n  options?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Embeddings Task Data\r\n */\r\nexport interface EmbeddingsTaskData {\r\n  texts: string[];\r\n  modelId?: string;\r\n  dimensions?: number;\r\n}\r\n\r\n/**\r\n * File Operation Task Data\r\n */\r\nexport interface FileOperationTaskData {\r\n  operation: \"read\" | \"write\" | \"delete\" | \"copy\" | \"move\";\r\n  sourcePath: string;\r\n  destinationPath?: string;\r\n  content?: string;\r\n  options?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * External API Task Data\r\n */\r\nexport interface ExternalApiTaskData {\r\n  url: string;\r\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\r\n  headers?: Record<string, string>;\r\n  body?: any;\r\n  timeout?: number;\r\n}\r\n","/* eslint-disable no-restricted-globals */\r\nimport { WorkerMessageType, TaskType } from \"../types/Task\";\r\n\r\n// Ensure TypeScript recognizes this as a worker\r\ndeclare const self: Worker;\r\n\r\n// Worker context - not exposed to global scope\r\nlet workerId: string | null = null;\r\nlet config: any = {};\r\nlet isReady = false;\r\n\r\n/**\r\n * Initialize the worker\r\n */\r\nfunction initialize(id: string, workerConfig: any): void {\r\n  workerId = id;\r\n  config = workerConfig || {};\r\n  isReady = true;\r\n\r\n  // Notify manager that worker is ready\r\n  self.postMessage({\r\n    type: WorkerMessageType.WORKER_READY,\r\n    workerId: workerId,\r\n    timestamp: new Date(),\r\n  });\r\n}\r\n\r\n/**\r\n * Execute a task\r\n */\r\nasync function executeTask(\r\n  taskId: string,\r\n  taskType: TaskType,\r\n  taskData: any\r\n): Promise<void> {\r\n  try {\r\n    // Report progress at 0%\r\n    reportProgress(taskId, 0);\r\n\r\n    let result;\r\n\r\n    // Execute appropriate task handler based on type\r\n    switch (taskType) {\r\n      case TaskType.MODEL_REQUEST:\r\n        result = await handleModelRequest(taskData);\r\n        break;\r\n\r\n      case TaskType.EMBEDDINGS:\r\n        result = await handleEmbeddings(taskData);\r\n        break;\r\n\r\n      case TaskType.FILE_OPERATION:\r\n        result = await handleFileOperation(taskData);\r\n        break;\r\n\r\n      case TaskType.DATA_PROCESSING:\r\n        result = await handleDataProcessing(taskData);\r\n        break;\r\n\r\n      case TaskType.EXTERNAL_API:\r\n        result = await handleExternalApi(taskData);\r\n        break;\r\n\r\n      case TaskType.CUSTOM:\r\n        result = await handleCustomTask(taskData);\r\n        break;\r\n\r\n      default:\r\n        throw new Error(`Unknown task type: ${taskType}`);\r\n    }\r\n\r\n    // Report progress at 100%\r\n    reportProgress(taskId, 100);\r\n\r\n    // Report task completion\r\n    self.postMessage({\r\n      type: WorkerMessageType.TASK_COMPLETED,\r\n      taskId,\r\n      workerId,\r\n      data: result,\r\n      timestamp: new Date(),\r\n    });\r\n  } catch (error) {\r\n    // Report task failure\r\n    self.postMessage({\r\n      type: WorkerMessageType.TASK_FAILED,\r\n      taskId,\r\n      workerId,\r\n      error: error instanceof Error ? error.message : String(error),\r\n      timestamp: new Date(),\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Report task progress\r\n */\r\nfunction reportProgress(taskId: string, progress: number): void {\r\n  self.postMessage({\r\n    type: WorkerMessageType.TASK_PROGRESS,\r\n    taskId,\r\n    workerId,\r\n    progress,\r\n    timestamp: new Date(),\r\n  });\r\n}\r\n\r\n/**\r\n * Report worker error\r\n */\r\nfunction reportError(error: any): void {\r\n  self.postMessage({\r\n    type: WorkerMessageType.WORKER_ERROR,\r\n    workerId,\r\n    error: error instanceof Error ? error.message : String(error),\r\n    timestamp: new Date(),\r\n  });\r\n}\r\n\r\n// Setup message handler\r\nself.onmessage = async (event) => {\r\n  const message = event.data;\r\n\r\n  try {\r\n    switch (message.type) {\r\n      case \"initialize\":\r\n        initialize(message.workerId, message.config);\r\n        break;\r\n\r\n      case \"execute\":\r\n        if (!isReady) {\r\n          throw new Error(\"Worker not initialized\");\r\n        }\r\n\r\n        await executeTask(message.taskId, message.taskType, message.taskData);\r\n        break;\r\n\r\n      default:\r\n        console.warn(`Unknown message type: ${message.type}`);\r\n        break;\r\n    }\r\n  } catch (error) {\r\n    reportError(error);\r\n  }\r\n};\r\n\r\n// Task handlers\r\n\r\n/**\r\n * Handle model request task\r\n */\r\nasync function handleModelRequest(data: any): Promise<any> {\r\n  // Simulate processing time\r\n  await sleep(1000);\r\n\r\n  // Mock implementation - in a real app, this would call an AI model\r\n  return {\r\n    text: `Response to prompt: ${data.prompt.substring(0, 50)}...`,\r\n    tokens: data.prompt.length / 4,\r\n    model: data.modelId || \"default\",\r\n  };\r\n}\r\n\r\n/**\r\n * Handle embeddings task\r\n */\r\nasync function handleEmbeddings(data: any): Promise<any> {\r\n  // Simulate processing time\r\n  await sleep(Math.min(500 * data.texts.length, 3000));\r\n\r\n  // Report progress halfway\r\n  reportProgress(data.taskId, 50);\r\n\r\n  // Mock implementation - in a real app, this would generate actual embeddings\r\n  return {\r\n    embeddings: data.texts.map(() => {\r\n      // Generate random embedding vector (mock)\r\n      const dimensions = data.dimensions || 128;\r\n      const vector = new Array(dimensions);\r\n      for (let i = 0; i < dimensions; i++) {\r\n        vector[i] = Math.random() * 2 - 1; // Values between -1 and 1\r\n      }\r\n      return vector;\r\n    }),\r\n  };\r\n}\r\n\r\n/**\r\n * Handle file operation task\r\n */\r\nasync function handleFileOperation(data: any): Promise<any> {\r\n  // Simulate processing time\r\n  await sleep(500);\r\n\r\n  // Report progress halfway\r\n  reportProgress(data.taskId, 50);\r\n\r\n  // Mock implementation - in a real app, this would perform actual file operations\r\n  return {\r\n    success: true,\r\n    operation: data.operation,\r\n    path: data.sourcePath,\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Handle data processing task\r\n */\r\nasync function handleDataProcessing(data: any): Promise<any> {\r\n  // Simulate processing time based on data size\r\n  const processingTime = Math.min(data.size || 1000, 5000);\r\n  const steps = 5;\r\n  const stepTime = processingTime / steps;\r\n\r\n  for (let i = 1; i <= steps; i++) {\r\n    await sleep(stepTime);\r\n    reportProgress(data.taskId, (i / steps) * 100);\r\n  }\r\n\r\n  // Mock implementation - in a real app, this would process actual data\r\n  return {\r\n    processed: true,\r\n    itemsProcessed: data.size || 100,\r\n    duration: processingTime,\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Handle external API task\r\n */\r\nasync function handleExternalApi(data: any): Promise<any> {\r\n  // Simulate network delay\r\n  await sleep(1500);\r\n\r\n  // Report progress halfway\r\n  reportProgress(data.taskId, 50);\r\n\r\n  // Mock implementation - in a real app, this would make actual API calls\r\n  return {\r\n    success: true,\r\n    url: data.url,\r\n    method: data.method,\r\n    responseCode: 200,\r\n    responseBody: {\r\n      message: \"Mock API response\",\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Handle custom task\r\n */\r\nasync function handleCustomTask(data: any): Promise<any> {\r\n  // Simulate processing time\r\n  const totalSteps = data.steps || 3;\r\n\r\n  for (let i = 1; i <= totalSteps; i++) {\r\n    await sleep(500);\r\n    reportProgress(data.taskId, (i / totalSteps) * 100);\r\n  }\r\n\r\n  // Process based on custom task data\r\n  return {\r\n    result: data.expectedResult || \"Custom task completed\",\r\n    custom: true,\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Helper function to sleep for a given time\r\n */\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n"],"names":["TaskType","WorkerMessageType","workerId","config","isReady","async","executeTask","taskId","taskType","taskData","result","reportProgress","MODEL_REQUEST","data","sleep","text","prompt","substring","tokens","length","model","modelId","handleModelRequest","EMBEDDINGS","Math","min","texts","embeddings","map","dimensions","vector","Array","i","random","handleEmbeddings","FILE_OPERATION","success","operation","path","sourcePath","timestamp","Date","toISOString","handleFileOperation","DATA_PROCESSING","processingTime","size","steps","stepTime","processed","itemsProcessed","duration","handleDataProcessing","EXTERNAL_API","url","method","responseCode","responseBody","message","handleExternalApi","CUSTOM","totalSteps","expectedResult","custom","handleCustomTask","Error","self","postMessage","type","TASK_COMPLETED","error","TASK_FAILED","String","progress","TASK_PROGRESS","ms","Promise","resolve","setTimeout","onmessage","event","id","workerConfig","WORKER_READY","console","warn","WORKER_ERROR","reportError"],"sourceRoot":""}